### 1) var 定义变量
var 可以定义一个**局部变量**, 如果不用`var` 可能导致无意识创建一个全局变量 

```js
function f() {
	a = 100;
	var b = 200;
}

f();
console.log(a);
console.log(b);
```
输出的结果 

```txt
100
console.log(b);
            ^
ReferenceError: b is not defined
```

### 2) javascript 变量提升 和 函数提升

**ES6**之前并没有块作用域，只有**全局作用域**和**函数作用域**。 

js中定义变量，不管在什么地方定义的，相当于是在**作用域的顶部定义的**,或者说似乎作用域开始的部分,这个叫做**变量提升**。 


变量进入作用域的四种方式 
1. 语言内置，比如 this , arguments
2. 形式参数，函数中的形式产生
3. 函数中的声明中的变量
4. 函数之外的声明的变量


**函数提升** 
```js
f();

function f()  {
	console.log('hello');
}
```
虽然代码中， `f函数`执行在前，定义在后。 但是由于**提升**的原因
,代码的真实执行相当于


```js
function f()  {
	console.log('hello');
}

f();
```
需要明白的，javascript 的执行是先解析代码，然后执行。
**变量提前**是发生在解析后，执行前的。所以需要使用变量的时候，就在作用域开始的地方，进行定义。


### 3) ES6 中的块作用域

``` js
{
	let b = 100;
	console.log(b);
}

console.log(b);
```
第一个**console.log**可以正常输出，第二个 **console.log**
```txt
ReferenceError: b is not defined
```


### 4) continue, break 和 **goto ** js 没有goto 


javacript 中 **continue** 和
**break**后面可以跟上一个标签，用于跳转。这个跳转的作用是改变循环，而**不是任意的跳转**。
**c语言**的中的**goto**是任意跳转的。

javascript 中的 ** break, continue ** 后面跟上 一个标签通常是用于跳出
**多层循环用的**。

比如下面的鸡兔同笼文件, 可以跳出两层循环。
```js
var chicken, rabbit;
var ans = 0;

show_ans:

for(chicken = 0; chicken <= 100; chicken++) {
	for(rabbit = 0; rabbit <= 100; rabbit++) {
		head = chicken + rabbit;
		leg = chicken * 2 + rabbit * 4;

		if( (leg == 94) && (head == 35)) {
			ans = [ rabbit, chicken ];
			break  show_ans;
		}
	}
}


console.log(ans);
```

如果用**c语言**

```c
#include <stdio.h>

int main() {
	int chicken, rabbit;
	int ans = 0;
	int head, leg;

	for(chicken = 0; chicken <= 100; chicken++) {
		for(rabbit = 0; rabbit <= 100; rabbit++) {

			head = chicken + rabbit;
			leg = chicken * 2 + rabbit * 4;

			if( (leg == 94) && (head == 35)) {
goto  show_ans;
			}
		}
	}

	printf(" not exits \n");
show_ans:
	printf("chicken = %d rabbit = %d \n", chicken, rabbit);

	return 0;

}
```
这里的 语句 ` printf(" not exits \n"); ` 是不会执行的。

